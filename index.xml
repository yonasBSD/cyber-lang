<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Cyber Docs v0.2</title><link>https://fubark.github.io/cyber/</link><description>Recent content in Introduction on Cyber Docs v0.2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://fubark.github.io/cyber/index.xml" rel="self" type="application/rss+xml"/><item><title>Syntax</title><link>https://fubark.github.io/cyber/docs/toc/syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/syntax/</guid><description>Syntax # Cyber&amp;rsquo;s syntax is concise while still being easy to read and understand.
Statements. # In Cyber, a statement ends with the new line. A statement block is not surrounded by delimiters like braces. Instead, the beginning of a block starts with a colon. This is intended to make a clear distinction between expressions and structured statements.
-- This is a statement. a = 123 -- This statement begins a new block.</description></item><item><title>Data Types</title><link>https://fubark.github.io/cyber/docs/toc/data-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/data-types/</guid><description>Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&amp;rsquo;t need additional heap memory or reference counts. Primitives include Booleans, Numbers, Integers, Enums, Symbols, Errors, Static Strings, and the none value. Object types include Lists, Maps, Strings, Custom Objects, Lambdas, Fibers, Errors with payloads, Pointers, and several internal object types.
The none value represents an empty value. This is similar to null in other languages.</description></item><item><title>Control Flow</title><link>https://fubark.github.io/cyber/docs/toc/control-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/control-flow/</guid><description>Control Flow. # Cyber provides the common constructs to branch and enter loops.
Branching. # Use if and else statements to branch the execution of your code depending on conditions. The else clause can contain a condition which is only evaluated if the previous if or conditional else clause was false.
a = 10 if a == 10: print &amp;#39;a is 10&amp;#39; else a == 20: print &amp;#39;a is 20&amp;#39; else: print &amp;#39;neither 10 nor 20&amp;#39; An if expression also needs the then keyword.</description></item><item><title>Functions</title><link>https://fubark.github.io/cyber/docs/toc/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/functions/</guid><description>Functions. # In Cyber, there are first-class functions (or function values) as well as statically defined functions.
Static Functions. # Static functions are not initally values themselves. They allow function calls to be optimal since they don&amp;rsquo;t need to resolve a dynamic value. A nice feature of Cyber&amp;rsquo;s static functions is they can be used just like a function value.
Static functions are declared with the func keyword and must have a name.</description></item><item><title>Modules</title><link>https://fubark.github.io/cyber/docs/toc/modules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/modules/</guid><description>Modules. # Modules have their own namespace and contain accessible static symbols. By default, importing another Cyber script returns a module with its declared symbols.
Importing. # Import declarations create a local alias to the module referenced by the import specifier. The Cyber CLI comes with some builtin modules like math and test. If the specifier does not refer to a builtin module, it looks for a Cyber script file relative to the current script&amp;rsquo;s directory.</description></item><item><title>FFI</title><link>https://fubark.github.io/cyber/docs/toc/ffi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/ffi/</guid><description>FFI. # Cyber supports binding to an existing C ABI compatible library at runtime. This allows you to call into dynamic libraries created in C or other languages. Cyber uses libtcc to JIT compile the bindings so function calls are fast. bindLib is part of the os module and accepts the path to the library as a string and a list of CFunc or CStruct declarations.
import os &amp;#39;os&amp;#39; lib = os.</description></item><item><title>Error Handling</title><link>https://fubark.github.io/cyber/docs/toc/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/errors/</guid><description>Error Handling. # Cyber provides error values and try/catch mechanisms to handle expected errors. For unexpected errors, panics can be used as a fail-fast mechanism to abort the currently running fiber.
Error value. # The error type is a primitive that contains either an enum value or a symbol value. Errors can wrap symbols for convenience but the underlying ID value won&amp;rsquo;t be consistent. Use your own enums if you want reliable ID values.</description></item><item><title>Concurrency</title><link>https://fubark.github.io/cyber/docs/toc/concurrency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/concurrency/</guid><description>Concurrency. # Cyber supports fibers as a concurrency mechanism. There are plans to support preemptive concurrency with async/await as well as multithreading.
Fibers. # Fibers in Cyber allow representing execution contexts as first-class values. They contain their own call stack and program counters. Fibers by themselves do not enable parallelism.
The coinit creates a new fiber from a function call syntax. Using coyield inside a function pauses the current fiber and execution is returned to the fiber that invoked coresume.</description></item><item><title>Type System</title><link>https://fubark.github.io/cyber/docs/toc/type-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/type-system/</guid><description>Type System. # Cyber supports gradual typing which allows the use of both dynamically and statically typed code.
Dynamic typing can reduce the amount of friction when writing code, but it can also result in more runtime errors. Gradual typing allows you to add static typing incrementally which provides compile-time guarantees and prevents runtime errors. Static typing also makes it easier to maintain and refactor your code.
Dynamic typing. # A variable with the any type can hold any value.</description></item><item><title>Metaprogramming</title><link>https://fubark.github.io/cyber/docs/toc/metaprogramming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/metaprogramming/</guid><description>Metaprogramming. # Operator overloading. # Custom operators. # Magic functions. # Calling a module symbol. # Declare a &amp;lt;call&amp;gt; function to allow invoking a module as a function. Currently, this is only available to builtin types like number.
-- Type declarations are also modules. type Vec2 object: x number y number func &amp;lt;call&amp;gt;(x number, y number) Vec2: return Vec2{ x: x, y: y } v = Vec2(1, 2) Reflection. # A metatype object references an internal type.</description></item><item><title>Embedding</title><link>https://fubark.github.io/cyber/docs/toc/embedding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/embedding/</guid><description> Embedding. #</description></item><item><title>Memory</title><link>https://fubark.github.io/cyber/docs/toc/memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/memory/</guid><description>Memory. # Cyber provides memory safety by default.
ARC. # Cyber uses ARC or automatic reference counting to manage memory. ARC has less overhead compared to a tracing garbage collector and reduces GC pauses which makes Cyber suitable for realtime applications. ARC is also deterministic unlike tracing GCs which usually run on a separate thread(s).
Reference Counting. # In Cyber, there are primitive and object values. Primitives don&amp;rsquo;t need any memory management, since they are copied by value and no heap allocation is required (with the exception of primitives being captured by a closure).</description></item></channel></rss>