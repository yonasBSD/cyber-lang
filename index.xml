<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Cyber Docs v0.1</title><link>https://fubark.github.io/cyber/</link><description>Recent content in Introduction on Cyber Docs v0.1</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://fubark.github.io/cyber/index.xml" rel="self" type="application/rss+xml"/><item><title>Syntax</title><link>https://fubark.github.io/cyber/docs/toc/syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/syntax/</guid><description>Syntax # Cyber&amp;rsquo;s syntax is concise while still being easy to read and understand.
Statements. # In Cyber, a statement ends with the new line. A statement block is not surrounded by delimiters like braces. Instead, the beginning of a block starts with a colon. This is intended to make a clear distinction between expressions and structured statements.
-- This is a statement. a = 123 -- This statement begins a new block.</description></item><item><title>Data Types</title><link>https://fubark.github.io/cyber/docs/toc/data-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/data-types/</guid><description>Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&amp;rsquo;t need additional heap memory or reference counts. Primitives include Booleans, Numbers, Integers, Tags, Tag Literals, Errors, Static Strings, and the none value. Object types include Lists, Maps, Strings, Custom Objects, Lambdas, Fibers, Errors with payloads, and several internal object types.
The none value represents an empty value. This is similar to null in other languages.</description></item><item><title>Control Flow</title><link>https://fubark.github.io/cyber/docs/toc/control-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/control-flow/</guid><description>Control Flow. # Cyber provides the common constructs to branch and enter loops.
Branching. # Use if and else statements to branch the execution of your code depending on conditions. The else clause can contain a condition which is only evaluated if the previous if or conditional else clause was false.
a = 10 if a == 10: print &amp;#39;a is 10&amp;#39; else a == 20: print &amp;#39;a is 20&amp;#39; else: print &amp;#39;neither 10 nor 20&amp;#39; An if expression also needs the then keyword.</description></item><item><title>Functions</title><link>https://fubark.github.io/cyber/docs/toc/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/functions/</guid><description>Functions. # In Cyber, there are first-class functions (or function values) as well as statically defined functions.
Static Functions. # Static functions are not initally values themselves. They allow function calls to be optimal since they don&amp;rsquo;t need to resolve a dynamic value. A nice feature of Cyber&amp;rsquo;s static functions is they can be used just like a function value.
Static functions are declared with the func keyword and must have a name.</description></item><item><title>Modules</title><link>https://fubark.github.io/cyber/docs/toc/modules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/modules/</guid><description>Modules. # Modules contain accessible static symbols under a defined namespace. By default, importing another Cyber script returns its module with exported symbols.
Importing. # Import declarations create a local alias to the module referenced by the import specifier. The Cyber CLI comes with some builtin modules like math and test. If the specifier does not refer to a builtin module, it looks for a Cyber script file relative to the current script&amp;rsquo;s directory.</description></item><item><title>FFI</title><link>https://fubark.github.io/cyber/docs/toc/ffi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/ffi/</guid><description>FFI. # Cyber supports binding to an existing C ABI compatible library at runtime. This allows you to call into dynamic libraries created in C or other languages. Cyber uses libtcc to JIT compile the bindings so function calls are fast. bindLib is part of the os module and accepts the path to the library as a string and a list of CFunc or CStruct declarations.
import os &amp;#39;os&amp;#39; lib = os.</description></item><item><title>Error Handling</title><link>https://fubark.github.io/cyber/docs/toc/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/errors/</guid><description>Error Handling. # In Cyber, errors are values and do not propogate up the call stack by default. Users are not forced to handle errors unless the error value is passed to a typed destination.
The error type is a primitive that contains either a tag or a tag literal. Tag literals can be used for convenience but the underlying id value can not be statically defined. Use your own tags if you want reliable id values.</description></item><item><title>Concurrency</title><link>https://fubark.github.io/cyber/docs/toc/concurrency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/concurrency/</guid><description>Concurrency. # Cyber supports fibers as a concurrency mechanism. There are plans to support preemptive concurrency with async/await as well as multithreading.
Fibers. # Fibers in Cyber allow representing execution contexts as first-class values. They contain their own call stack and program counters. Fibers by themselves do not enable parallelism.
The coinit creates a new fiber from a function call syntax. Using coyield inside a function pauses the current fiber and execution is returned to the fiber that invoked coresume.</description></item><item><title>Metaprogramming</title><link>https://fubark.github.io/cyber/docs/toc/metaprogramming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/metaprogramming/</guid><description> Metaprogramming. # Runtime Eval. # Compile-time. # Generics. #</description></item><item><title>Embedding</title><link>https://fubark.github.io/cyber/docs/toc/embedding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/embedding/</guid><description> Embedding. #</description></item><item><title>Gradual Typing</title><link>https://fubark.github.io/cyber/docs/toc/gradual-typing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/gradual-typing/</guid><description> Gradual Typing. #</description></item><item><title>Memory</title><link>https://fubark.github.io/cyber/docs/toc/memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/memory/</guid><description> Memory. # ARC. # Heap. # Weak Refs. # Cycle Detection. #</description></item></channel></rss>