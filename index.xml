<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Cyber Docs v0.2</title><link>https://fubark.github.io/cyber/</link><description>Recent content in Introduction on Cyber Docs v0.2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://fubark.github.io/cyber/index.xml" rel="self" type="application/rss+xml"/><item><title>Syntax</title><link>https://fubark.github.io/cyber/docs/toc/syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/syntax/</guid><description>Syntax # Cyber&amp;rsquo;s syntax is concise and easy to read.
Statements. # A statement ends with the new line.
-- An assignment statement. var a = 123 Blocks. # A new block starts with a colon. This is intended to give structure to nested statements without an ending delimiter.
-- This `if` statement begins a new block. if true: var a = 234 The first statement in a block must be indented further.</description></item><item><title>Data Types</title><link>https://fubark.github.io/cyber/docs/toc/data-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/data-types/</guid><description>Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&amp;rsquo;t need additional heap memory or reference counts. Primitives include Booleans, Floats, Integers, Enums, Symbols, Errors, Static Strings, and the none value. Object types include Lists, Maps, Strings, Custom Objects, Lambdas, Fibers, Errors with payloads, Pointers, and several internal object types.
The none value represents an empty value. This is similar to null in other languages.</description></item><item><title>Control Flow</title><link>https://fubark.github.io/cyber/docs/toc/control-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/control-flow/</guid><description>Control Flow. # Cyber provides the common constructs to branch and enter loops.
Branching. # Use if and else statements to branch the execution of your code depending on conditions. The else clause can contain a condition which is only evaluated if the previous if or conditional else clause was false.
var a = 10 if a == 10: print &amp;#39;a is 10&amp;#39; else a == 20: print &amp;#39;a is 20&amp;#39; else: print &amp;#39;neither 10 nor 20&amp;#39; An if expression also needs the then keyword.</description></item><item><title>Functions</title><link>https://fubark.github.io/cyber/docs/toc/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/functions/</guid><description>Functions. # In Cyber, there are first-class functions (or function values) and static functions.
Static Functions. # Static functions are not initially values themselves. They allow function calls to be optimal since they don&amp;rsquo;t need to resolve a dynamic value.
Static functions are declared with the func keyword and must have a name.
import m &amp;#39;math&amp;#39; func dist(x0, y0, x1, y1): var dx = x0-x1 var dy = y0-y1 return m.</description></item><item><title>Modules</title><link>https://fubark.github.io/cyber/docs/toc/modules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/modules/</guid><description>Modules. # Modules have their own namespace and contain accessible static symbols. By default, importing another Cyber script returns a module with its declared symbols.
Importing. # Import declarations create a local alias to the module referenced by the import specifier. The Cyber CLI comes with some builtin modules like math and test. If the specifier does not refer to a builtin module, it looks for a Cyber script file relative to the current script&amp;rsquo;s directory.</description></item><item><title>FFI</title><link>https://fubark.github.io/cyber/docs/toc/ffi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/ffi/</guid><description>FFI. # Cyber supports binding to an existing C ABI compatible library at runtime. This allows you to call into dynamic libraries created in C or other languages. Cyber uses libtcc to JIT compile the bindings so function calls are fast. bindLib is part of the os module and accepts the path to the library as a string and a list of CFunc or CStruct declarations.
import os &amp;#39;os&amp;#39; var lib = os.</description></item><item><title>Error Handling</title><link>https://fubark.github.io/cyber/docs/toc/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/errors/</guid><description>Error Handling. # Cyber provides error values and try/catch mechanisms to handle expected errors. For unexpected errors, panics can be used as a fail-fast mechanism to abort the currently running fiber.
Error value. # The error type is a primitive that contains either an enum value or a symbol value. Errors can wrap symbols for convenience but the underlying ID value won&amp;rsquo;t be consistent. Use your own enums if you want reliable ID values.</description></item><item><title>Concurrency</title><link>https://fubark.github.io/cyber/docs/toc/concurrency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/concurrency/</guid><description>Concurrency. # Cyber supports fibers as a concurrency mechanism. There are plans to support preemptive concurrency with async/await as well as multithreading.
Fibers. # Fibers in Cyber allow representing execution contexts as first-class values. They contain their own call stack and program counters. Fibers by themselves do not enable parallelism.
The coinit creates a new fiber from a function call syntax. Using coyield inside a function pauses the current fiber and execution is returned to the fiber that invoked coresume.</description></item><item><title>Type System</title><link>https://fubark.github.io/cyber/docs/toc/type-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/type-system/</guid><description>Type System. # Cyber supports gradual typing which allows the use of both dynamically and statically typed code.
Incomplete: Types in general is in development. One of the goals of Cyber is to let dynamic code mix with typed code. At the moment, there are places where it works and other places where it won&amp;rsquo;t. Keep that in mind when using types.
Dynamic typing can reduce the amount of friction when writing code, but it can also result in more runtime errors.</description></item><item><title>Metaprogramming</title><link>https://fubark.github.io/cyber/docs/toc/metaprogramming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/metaprogramming/</guid><description>Metaprogramming. # Operator overloading. # All operators are implemented as object methods.
Incomplete: Not all operators have transitioned to the method paradigm.
Normally this would impact performance, but Cyber&amp;rsquo;s compiler generates specialized bytecode ops for builtin types like int and float. The VM performs inline caching at runtime to eliminate the overhead of evaluating operators on dynamic operands.
To overload an operator for a object type, declare $prefix, $infix, $postfix methods:</description></item><item><title>Embedding</title><link>https://fubark.github.io/cyber/docs/toc/embedding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/embedding/</guid><description>Embedding. # Planned Feature</description></item><item><title>Memory</title><link>https://fubark.github.io/cyber/docs/toc/memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/memory/</guid><description>Memory. # Cyber provides memory safety by default.
ARC. # Cyber uses ARC or automatic reference counting to manage memory. ARC is deterministic and has less overhead compared to a tracing garbage collector. Reference counting distributes memory management, which reduces GC pauses and makes ARC suitable for realtime applications. One common issue in ARC implementations is reference cycles which Cyber addresses with Weak References and it&amp;rsquo;s very own Cycle Detection.</description></item><item><title>AOT/JIT</title><link>https://fubark.github.io/cyber/docs/toc/aot-jit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/aot-jit/</guid><description>AOT and JIT # Planned Feature</description></item></channel></rss>