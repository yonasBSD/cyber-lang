<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&rsquo;t need additional heap memory or reference counts. Primitives include Booleans, Floats, Integers, Enums, Symbols, Errors, Static Strings, and the none value. Object types include Lists, Maps, Strings, Custom Objects, Lambdas, Fibers, Errors with payloads, Pointers, and several internal object types.
The none value represents an empty value. This is similar to null in other languages."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Data Types"><meta property="og:description" content="Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&rsquo;t need additional heap memory or reference counts. Primitives include Booleans, Floats, Integers, Enums, Symbols, Errors, Static Strings, and the none value. Object types include Lists, Maps, Strings, Custom Objects, Lambdas, Fibers, Errors with payloads, Pointers, and several internal object types.
The none value represents an empty value. This is similar to null in other languages."><meta property="og:type" content="article"><meta property="og:url" content="https://fubark.github.io/cyber/docs/toc/data-types/"><meta property="article:section" content="docs"><title>Data Types | Cyber Docs v0.2</title><link rel=manifest href=/cyber/manifest.json><link rel=icon href=/cyber/favicon.png><link rel=stylesheet href=/cyber/book.min.4f0117e74e5337280f18eb9641eae520cb4b25adcf5dd64fafad4664145a5957.css integrity="sha256-TwEX505TNygPGOuWQerlIMtLJa3PXdZPr61GZBRaWVc=" crossorigin=anonymous><script defer src=/cyber/flexsearch.min.js></script>
<script defer src=/cyber/en.search.min.db402b8c46fe1829b7c32e1613e5e896d742a3010e5975362d629f119703c98d.js integrity="sha256-20ArjEb+GCm3wy4WE+XoltdCowEOWXU2LWKfEZcDyY0=" crossorigin=anonymous></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel=stylesheet><link rel=stylesheet href=/cyber/hljs.min.css><link rel=stylesheet href=/cyber/style.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/cyber/><span>Cyber Docs v0.2</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://cyberscript.dev target=_blank rel=noopener>Homepage</a></li><li><a href=https://cyberscript.dev/play.html target=_blank rel=noopener>Playground</a></li></ul><ul><li class=book-section-flat><span>Table of Contents</span><ul><li><a href=/cyber/docs/toc/syntax/>Syntax</a></li><li><a href=/cyber/docs/toc/data-types/ class=active>Data Types</a></li><li><a href=/cyber/docs/toc/control-flow/>Control Flow</a></li><li><a href=/cyber/docs/toc/functions/>Functions</a></li><li><a href=/cyber/docs/toc/modules/>Modules</a></li><li><a href=/cyber/docs/toc/ffi/>FFI</a></li><li><a href=/cyber/docs/toc/errors/>Error Handling</a></li><li><a href=/cyber/docs/toc/concurrency/>Concurrency</a></li><li><a href=/cyber/docs/toc/type-system/>Type System</a></li><li><a href=/cyber/docs/toc/metaprogramming/>Metaprogramming</a></li><li><a href=/cyber/docs/toc/embedding/>Embedding</a></li><li><a href=/cyber/docs/toc/memory/>Memory</a></li><li><a href=/cyber/docs/toc/aot-jit/>AOT/JIT</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/cyber/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Data Types</strong>
<label for=toc-control><img src=/cyber/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#booleans>Booleans.</a></li><li><a href=#numbers>Numbers.</a><ul><li><a href=#integers>Integers.</a></li><li><a href=#floats>Floats.</a></li><li><a href=#big-numbers>Big Numbers.</a></li></ul></li><li><a href=#strings>Strings.</a><ul><li><a href=#type-string><code>type string</code></a></li><li><a href=#string-interpolation>String Interpolation.</a></li><li><a href=#rawstring>rawstring.</a></li><li><a href=#type-rawstring><code>type rawstring</code></a></li></ul></li><li><a href=#lists>Lists.</a><ul><li><a href=#type-list><code>type List</code></a></li></ul></li><li><a href=#maps>Maps.</a><ul><li><a href=#type-map><code>type Map</code></a></li></ul></li><li><a href=#objects>Objects.</a><ul><li><a href=#methods>Methods.</a></li></ul></li><li><a href=#enums>Enums.</a></li><li><a href=#symbols>Symbols.</a></li></ul></nav></aside></header><article class=markdown><h1 id=data-types>Data Types.
<a class=anchor href=#data-types>#</a></h1><p>In Cyber, there are primitive types and object types. Primitives are copied around by value and don&rsquo;t need additional heap memory or reference counts. Primitives include <a href=#booleans>Booleans</a>, <a href=#floats>Floats</a>, <a href=#integers>Integers</a>, <a href=#enums>Enums</a>, <a href=#symbols>Symbols</a>, <a href=/cyber/docs/toc/errors/>Errors</a>, <a href=#strings>Static Strings</a>, and the <code>none</code> value. Object types include <a href=#lists>Lists</a>, <a href=#maps>Maps</a>, <a href=#strings>Strings</a>, <a href=#objects>Custom Objects</a>, <a href=/cyber/docs/toc/functions/#lambdas>Lambdas</a>, <a href=/cyber/docs/toc/concurrency/#fibers>Fibers</a>, <a href=/cyber/docs/toc/errors/>Errors with payloads</a>, <a href=/cyber/docs/toc/ffi/#pointers>Pointers</a>, and several internal object types.</p><p>The <code>none</code> value represents an empty value. This is similar to null in other languages.</p><h2 id=booleans>Booleans.
<a class=anchor href=#booleans>#</a></h2><p>Booleans can be <code>true</code> or <code>false</code>.</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = true
if a:
    print &#39;a is true&#39;
</code></pre><p>When other value types are coerced to the boolean type, the truthy value is determined as follows.</p><ul><li>The <code>none</code> value is <code>false</code>.</li><li>Other objects and values are always <code>true</code>.</li></ul><h2 id=numbers>Numbers.
<a class=anchor href=#numbers>#</a></h2><h3 id=integers>Integers.
<a class=anchor href=#integers>#</a></h3><p><code>int</code> is the default integer type. It has 48-bits and can represent integers in the range -(2<sup>47</sup>) to 2<sup>47</sup>-1.</p><p>When a numeric literal is used and the type can not be inferred, it will default to the <code>int</code> type:</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = 123
</code></pre><p>Integer notations always produce a <code>int</code> value:</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = 0xFF     -- hex.
a = 0o17         -- octal.
a = 0b1010       -- binary.
a = 0u&#39;üê∂&#39;       -- UTF-8 rune.
</code></pre><p>Arbitrary values can be converted to a <code>int</code> using the type as a function.</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = &#39;123&#39;
var b = int(a) 
</code></pre><p>In addition to arithmetic operations, integers can also perform <a href=/cyber/docs/toc/syntax/#bitwise-operators>bitwise operations</a>.</p><h3 id=floats>Floats.
<a class=anchor href=#floats>#</a></h3><p><code>float</code> is the default floating point type. It has a (IEEE 754) 64-bit floating point format.</p><p>Although a <code>float</code> represents a decimal number, it can also represent integers between -(2<sup>53</sup>-1) and (2<sup>53</sup>-1). Any integers beyond the safe integer range is not guaranteed to have a unique representation.</p><p>A numeric literal can be used to create a <code>float</code> if the inferred type is a <code>float</code>:</p><pre tabindex=0><code class=language-cy data-lang=cy>a float = 123
</code></pre><p>Decimal and scientific notations always produce a <code>float</code> value:</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = 2.34567
var b = 123.0e4
</code></pre><p>Arbitrary values can be converted to a <code>float</code> using the type as a function.</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = &#39;12.3&#39;
var b = float(a) 
</code></pre><h3 id=big-numbers>Big Numbers.
<a class=anchor href=#big-numbers>#</a></h3><blockquote><p><em>Planned Feature</em></p></blockquote><h2 id=strings>Strings.
<a class=anchor href=#strings>#</a></h2><p>The <code>string</code> type represents a sequence of UTF-8 codepoints, also known as <code>runes</code>. Each rune is stored internally as 1-4 bytes and can be represented as an <code>int</code>. Under the hood, Cyber implements 6 different internal string types to optimize string operations, but the user just sees them as one type and doesn&rsquo;t need to care about this detail under normal usage.</p><p>Strings are <strong>immutable</strong>, so operations that do string manipulation return a new string. By default, small strings are interned to reduce memory footprint. To mutate an existing string, use the <a href=#string-buffer>StringBuffer</a>.</p><blockquote><p><em>Planned Feature</em></p></blockquote><p>A string is always UTF-8 validated. <a href=#rawstring>rawstrings</a> outperform strings but you&rsquo;ll have to validate them and take care of indexing yourself.</p><p>A single line string literal is surrounded in single quotes.</p><pre tabindex=0><code class=language-cy data-lang=cy>var apple = &#39;a fruit&#39;
</code></pre><p>You can escape the single quote inside the literal or use double quotes.</p><pre tabindex=0><code class=language-cy data-lang=cy>var apple = &#39;Bob\&#39;s fruit&#39;
apple = &#34;Bob&#39;s fruit&#34;
</code></pre><p>Strings are UTF-8 encoded.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#39;abcü¶äxyzüê∂&#39;
</code></pre><p>Use double quotes to surround a multi-line string.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#34;line a
line b
line c&#34;
</code></pre><p>You can escape double quotes inside the literal or use triple quotes.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#34;line a
line \&#34;b\&#34;
line c&#34;

-- Using triple quotes.
str = &#39;&#39;&#39;line a
line &#34;b&#34;
line c
&#39;&#39;&#39;
</code></pre><p>The following escape sequences are supported:</p><table><thead><tr><th>Escape Sequence</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>\a</td><td>0x07</td><td>Terminal bell.</td></tr><tr><td>\b</td><td>0x08</td><td>Backspace.</td></tr><tr><td>\e</td><td>0x1b</td><td>Escape character.</td></tr><tr><td>\n</td><td>0x0a</td><td>Line feed character.</td></tr><tr><td>\r</td><td>0x0d</td><td>Carriage return character.</td></tr><tr><td>\t</td><td>0x09</td><td>Horizontal tab character.</td></tr></tbody></table><p>The boundary of each line can be set with a vertical line character. This makes it easier to see the whitespace.</p><pre tabindex=0><code class=language-cy data-lang=cy>var poem = &#34;line a
       |  two spaces from the left
       |     indented further&#34;
</code></pre><p>Using the index operator will return the UTF-8 rune at the given index as a slice. This is equivalent to calling the method <code>sliceAt()</code>.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#39;abcd&#39;
print str[1]     -- &#34;b&#34;
print str[-1]    -- &#34;d&#34;
</code></pre><p>Using the slice index operator will return a view of the string at the given start and end (exclusive) indexes. The start index defaults to 0 and the end index defaults to the string&rsquo;s length.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#39;abcxyz&#39;
var sub = str[0..3]
print sub        -- &#34;abc&#34;
print str[..5]   -- &#34;abcxy&#34;
print str[1..]   -- &#34;bcxyz&#34;

-- One way to use slices is to continue a string operation.
str = &#39;abcabcabc&#39;
var i = str.findRune(0u&#39;c&#39;)
print(i)                            -- &#34;2&#34;
i += 1
print(i + str[i..].findRune(0u&#39;c&#39;))  -- &#34;5&#34;
</code></pre><h3 id=type-string><code>type string</code>
<a class=anchor href=#type-string>#</a></h3><pre tabindex=0><code class=language-cy data-lang=cy>func concat(self, str string) string
-- Returns a new string that concats this string and `str`.

func endsWith(self, suffix string) bool
-- Returns whether the string ends with `suffix`.

func find(self, needle string) int?
-- Returns the first index of substring `needle` in the string or `none` if not found.

func findAnyRune(self, set string) int?
-- Returns the first index of any UTF-8 rune in `set` or `none` if not found.

func findRune(self, needle int) int?
-- Returns the first index of UTF-8 rune `needle` in the string or `none` if not found.

func insert(self, idx int, str string) string
-- Returns a new string with `str` inserted at index `idx`.

func isAscii(self) bool
-- Returns whether the string contains all ASCII runes.

func len(self) int
-- Returns the number of UTF-8 runes in the string.

func less(self, str string) bool
-- Returns whether this string is lexicographically before `str`.

func lower(self) string
-- Returns this string in lowercase.

func replace(self, needle string, replacement string) string
-- Returns a new string with all occurrences of `needle` replaced with `replacement`. | 

func repeat(self, n int) string
-- Returns a new string with this string repeated `n` times.

func runeAt(self, idx int) int
-- Returns the UTF-8 rune at index `idx`.

func slice(self, start int, end int) string
-- Returns a slice into this string from `start` to `end` (exclusive) indexes. This is equivalent to using the slice index operator `[start..end]`.

func sliceAt(self, idx int) string
-- Returns the UTF-8 rune at index `idx` as a single rune string.

func split(self, delim string) List
-- Returns a list of UTF-8 strings split at occurrences of `delim`.

func startsWith(self, prefix string) bool
-- Returns whether the string starts with `prefix`.

func trim(self, mode symbol, trimRunes any) string
-- Returns the string with ends trimmed from runes in `trimRunes`. `mode` can be #left, #right, or #ends.

func upper(self) string
-- Returns this string in uppercase.
</code></pre><h3 id=string-interpolation>String Interpolation.
<a class=anchor href=#string-interpolation>#</a></h3><p>You can embed expressions into string templates using braces.</p><pre tabindex=0><code class=language-cy data-lang=cy>var name = &#39;Bob&#39;
var points = 123
var str = &#39;Scoreboard: {name} {points}&#39;
</code></pre><p>Escape braces with a backslash.</p><pre tabindex=0><code class=language-cy data-lang=cy>var points = 123
var str = &#39;Scoreboard: \{ Bob \} {points}&#39;
</code></pre><p>String templates can not contain nested string templates.</p><h3 id=rawstring>rawstring.
<a class=anchor href=#rawstring>#</a></h3><p>A <code>rawstring</code> does not automatically validate the string and is indexed by bytes and not UTF-8 runes.</p><p>Using the index operator will return the UTF-8 rune starting at the given byte index as a slice. If the index does not begin a valid UTF-8 rune, <code>error.InvalidRune</code> is returned. This is equivalent to calling the method <code>sliceAt()</code>.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = rawstring(&#39;abcd&#39;).insertByte(1, 255)
print str[0]     -- &#34;a&#34;
print str[1]     -- error.InvalidRune
print str[-1]    -- &#34;d&#34;
</code></pre><h3 id=type-rawstring><code>type rawstring</code>
<a class=anchor href=#type-rawstring>#</a></h3><pre tabindex=0><code class=language-cy data-lang=cy>func byteAt(self, idx int) int
-- Returns the byte value (0-255) at the given index `idx`.

func concat(self, str string) string
-- Returns a new string that concats this string and `str`.

func endsWith(self, suffix string) bool
-- Returns whether the string ends with `suffix`.

func find(self, needle string) int?
-- Returns the first index of substring `needle` in the string or `none` if not found.

func findAnyRune(self, set string) int?
-- Returns the first index of any UTF-8 rune in `set` or `none` if not found.

func findRune(self, needle int) int?
-- Returns the first index of UTF-8 rune `needle` in the string or `none` if not found.

func insert(self, idx int, str string) string
-- Returns a new string with `str` inserted at index `idx`.

func insertByte(self, idx int, byte int) string
-- Returns a new string with `byte` inserted at index `idx`.

func isAscii(self) bool
-- Returns whether the string contains all ASCII runes.

func len(self) int
-- Returns the number of bytes in the string.

func less(self, str rawstring) bool
-- Returns whether this rawstring is lexicographically before `str`.

func lower(self) string
-- Returns this string in lowercase.

func repeat(self, n int) rawstring
-- Returns a new rawstring with this rawstring repeated `n` times.

func replace(self, needle string, replacement string) string
-- Returns a new string with all occurrences of `needle` replaced with `replacement`.

func runeAt(self, idx int) int
-- Returns the UTF-8 rune at index `idx`. If the index does not begin a UTF-8 rune, `error.InvalidRune` is returned.

func slice(self, start int, end int) rawstring
-- Returns a slice into this string from `start` to `end` (exclusive) indexes. This is equivalent to using the slice index operator `[start..end]`.

func sliceAt(self, idx int) string
-- Returns the UTF-8 rune at index `idx` as a single rune string. If the index does not begin a UTF-8 rune, `error.InvalidRune` is returned.

func split(self, delim string) List
-- Returns a list of rawstrings split at occurrences of `delim`.

func startsWith(self, prefix string) bool
-- Returns whether the string starts with `prefix`.

func upper(self) string
-- Returns this string in uppercase.

func trim(self, mode symbol, trimRunes any) rawstring
-- Returns the string with ends trimmed from runes in `trimRunes`. `mode` can be #left, #right, or #ends.

func utf8(self) string
-- Returns a valid UTF-8 string or returns `error.InvalidRune`.
</code></pre><h2 id=lists>Lists.
<a class=anchor href=#lists>#</a></h2><p>Lists are a builtin type that holds an ordered collection of elements. Lists grow or shrink as you insert or remove elements.</p><pre tabindex=0><code class=language-cy data-lang=cy>-- Construct a new list.
var list = [1, 2, 3]

-- The first element of the list starts at index 0.
print list[0]    -- Prints &#39;1&#39;

-- Using a negative index starts at the back of the list.
print list[-1]   -- Prints &#39;3&#39;
</code></pre><p>Lists can be sliced with the range <code>..</code> clause. The sliced list becomes a new list that you can modify without affecting the original list. The end index is non-inclusive. Negative start or end values count from the end of the list.</p><pre tabindex=0><code class=language-cy data-lang=cy>var list = [ 1, 2, 3, 4, 5 ]
list[0..0]  -- []          Empty list.
list[0..3]  -- [ 1, 2, 3 ] From start to end index.
list[3..]   -- [ 4, 5 ]    From start index to end of list. 
list[..3]   -- [ 1, 2, 3 ] From start of list to end index.
list[2..+2] -- [ 3, 4 ]    From start index to start index + amount.
</code></pre><p>List operations.</p><pre tabindex=0><code class=language-cy data-lang=cy>var list = [234]
-- Append a value.
list.append 123
print list[-1]     -- Prints &#39;123&#39;

-- Inserting a value at an index.
list.insert(1, 345)

-- Get the length.
print list.len()  -- Prints &#39;2&#39;

-- Sort the list in place.
list.sort((a, b) =&gt; a &lt; b)

-- Iterating a list.
for list each it:
    print it

-- Remove an element at a specific index.
list.remove(1)
</code></pre><h3 id=type-list><code>type List</code>
<a class=anchor href=#type-list>#</a></h3><table><thead><tr><th>Method</th><th>Summary</th></tr></thead><tbody><tr><td><code>append(val any) none</code></td><td>Appends a value to the end of the list.</td></tr><tr><td><code>concat(val any) none</code></td><td>Concats the elements of another list to the end of this list.</td></tr><tr><td><code>insert(idx int, val any) none</code></td><td>Inserts a value at index <code>idx</code>.</td></tr><tr><td><code>iterator() Iterator&lt;any></code></td><td>Returns a new iterator over the list elements.</td></tr><tr><td><code>joinString(separator any) string</code></td><td>Returns a new string that joins the elements with <code>separator</code>.</td></tr><tr><td><code>len() int</code></td><td>Returns the number of elements in the list.</td></tr><tr><td><code>pairIterator() PairIterator&lt;int, any></code></td><td>Returns a new pair iterator over the list elements.</td></tr><tr><td><code>remove(idx int) none</code></td><td>Removes an element at index <code>idx</code>.</td></tr><tr><td><code>resize(len int) none</code></td><td>Resizes the list to <code>len</code> elements. If the new size is bigger, <code>none</code> values are appended to the list. If the new size is smaller, elements at the end of the list are removed.</td></tr><tr><td><code>sort(less func (a, b) bool) none</code></td><td>Sorts the list with the given <code>less</code> function. If element <code>a</code> should be ordered before <code>b</code>, the function should return <code>true</code> otherwise <code>false</code>.</td></tr></tbody></table><h2 id=maps>Maps.
<a class=anchor href=#maps>#</a></h2><p>Maps are a builtin type that store key value pairs in dictionaries.</p><pre tabindex=0><code class=language-cy data-lang=cy>var map = { a: 123, b: () =&gt; 5 }
print map[&#39;a&#39;]

-- You can also access the map using an access expression.
print map.a

-- Map entries can be separated by the new line.
map = {
    foo: 1
    bar: 2
}
</code></pre><p>Entries can also follow a <code>{}:</code> block.
This gives structure to the entries and has
the added benefit of allowing multi-line lambdas.</p><blockquote><p><em>Planned Feature</em></p></blockquote><pre tabindex=0><code class=language-cy data-lang=cy>var colors = {}:
    red: 0xFF0000
    green: 0x00FF00
    blue: 0x0000FF
    dump func (c):
        print c.red
        print c.green
        print c.blue

    -- Nested map.
    darker {}: 
        red: 0xAA0000
        green: 0x00AA00
        blue: 0x0000AA
</code></pre><p>Map operations.</p><pre tabindex=0><code class=language-cy data-lang=cy>var map = {}
-- Set a key value pair.
map[123] = 234

-- Get the size of the map.
print map.size()

-- Remove an entry by key.
map.remove 123

-- Iterating a list.
for map each val, key:
    print &#39;{key} -&gt; {value}&#39;
</code></pre><h3 id=type-map><code>type Map</code>
<a class=anchor href=#type-map>#</a></h3><table><thead><tr><th>Method</th><th>Summary</th></tr></thead><tbody><tr><td><code>iterator() Iterator&lt;any></code></td><td>Returns a new iterator over the map elements.</td></tr><tr><td><code>pairIterator() PairIterator&lt;any, any></code></td><td>Returns a new pair iterator over the map elements.</td></tr><tr><td><code>remove(key any) none</code></td><td>Removes the element with the given key <code>key</code>.</td></tr><tr><td><code>size() int</code></td><td>Returns the number of key-value pairs in the map.</td></tr></tbody></table><h2 id=objects>Objects.
<a class=anchor href=#objects>#</a></h2><p>Any value that isn&rsquo;t a primitive is an object. You can declare your own object types using the <code>type object</code> declaration. Object types are similar to structs and classes in other languages. You can declare members and methods. Unlike classes, there is no concept of inheritance at the language level.</p><pre tabindex=0><code class=language-cy data-lang=cy>type Node object:
    value
    next

var node = Node{ value: 123, next: none }
print node.value          -- &#39;123&#39;
</code></pre><p>New instances of an object template are created using the type name and braces that surround the initial member values.</p><h3 id=methods>Methods.
<a class=anchor href=#methods>#</a></h3><p>The first parameter of a method must be <code>self</code>. Otherwise, it declares a static function that can only be invoked from the type&rsquo;s namespace.</p><pre tabindex=0><code class=language-cy data-lang=cy>type Node object:
    value
    next

    -- A static function.
    func create():
        return Node{ value: 123, next: none }

    -- A method.
    func dump(self):
        print self.value

var n = Node.create()
n.dump()
</code></pre><p>Although <code>self</code> is required in a method&rsquo;s signature, it&rsquo;s optional when referencing the type&rsquo;s members.</p><pre tabindex=0><code class=language-cy data-lang=cy>type Node object:
    value

    func double(self):
        return value * 2
</code></pre><h2 id=enums>Enums.
<a class=anchor href=#enums>#</a></h2><p>A new enum type can be declared with the <code>type enum</code> declaration.
An enum value can only be one of the unique symbols declared in the enum type.
By default, the symbols generate unique ids starting from 0.</p><pre tabindex=0><code class=language-cy data-lang=cy>type Fruit enum:
    apple
    orange
    banana
    kiwi

var fruit = Fruit.kiwi
print fruit       -- &#39;Fruit.kiwi&#39;
print int(fruit)  -- &#39;3&#39;
</code></pre><p>When the type of the value is known to be an enum, it can be assigned using a symbol literal.</p><pre tabindex=0><code class=language-cy data-lang=cy>var fruit = Fruit.kiwi
fruit = #orange
print(fruit == Fruit.orange)   -- &#39;true&#39;
</code></pre><h2 id=symbols>Symbols.
<a class=anchor href=#symbols>#</a></h2><p>Symbol literals begin with <code>#</code>, followed by an identifier. They have their own global unique id.</p><pre tabindex=0><code class=language-cy data-lang=cy>var currency = #usd
print(currency == #usd)   -- &#39;true&#39;
print int(currency)       -- &#39;123&#39; or some arbitrary id.
</code></pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/fubark/cyber/edit/master/docs/hugo/content/docs/toc/data-types.md target=_blank rel=noopener><img src=/cyber/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#booleans>Booleans.</a></li><li><a href=#numbers>Numbers.</a><ul><li><a href=#integers>Integers.</a></li><li><a href=#floats>Floats.</a></li><li><a href=#big-numbers>Big Numbers.</a></li></ul></li><li><a href=#strings>Strings.</a><ul><li><a href=#type-string><code>type string</code></a></li><li><a href=#string-interpolation>String Interpolation.</a></li><li><a href=#rawstring>rawstring.</a></li><li><a href=#type-rawstring><code>type rawstring</code></a></li></ul></li><li><a href=#lists>Lists.</a><ul><li><a href=#type-list><code>type List</code></a></li></ul></li><li><a href=#maps>Maps.</a><ul><li><a href=#type-map><code>type Map</code></a></li></ul></li><li><a href=#objects>Objects.</a><ul><li><a href=#methods>Methods.</a></li></ul></li><li><a href=#enums>Enums.</a></li><li><a href=#symbols>Symbols.</a></li></ul></nav></div></aside></main><script src=/cyber/highlight.min.js></script>
<script>hljs.registerLanguage("cy",function(){return{keywords:{keyword:["func","import","for","coinit","coresume","coyield","return","if","then","else","as","each","while","var","object","break","continue","match","pass","or","and","not","is","some","error","static","capture","true","false","none","throw","try","catch","recover","enum","type"],type:["float","string","bool","any","int","List","Map","rawstring","symbol","pointer"]},contains:[{scope:"string",begin:"'",end:"'"},{scope:"symbol",begin:"#",end:/\w(?=[^\w])/},hljs.COMMENT("--",`
`,{contains:[]}),hljs.C_NUMBER_MODE]}}),hljs.highlightAll()</script></body></html>