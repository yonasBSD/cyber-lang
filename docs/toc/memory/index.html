<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Memory. # Cyber provides memory safety by default.
ARC. # Cyber uses ARC or automatic reference counting to manage memory. ARC is deterministic and has less overhead compared to a tracing garbage collector. Reference counting distributes memory management, which reduces GC pauses and makes ARC suitable for realtime applications. One common issue in ARC implementations is reference cycles which Cyber addresses with Weak References and it&rsquo;s very own Cycle Detection."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Memory"><meta property="og:description" content="Memory. # Cyber provides memory safety by default.
ARC. # Cyber uses ARC or automatic reference counting to manage memory. ARC is deterministic and has less overhead compared to a tracing garbage collector. Reference counting distributes memory management, which reduces GC pauses and makes ARC suitable for realtime applications. One common issue in ARC implementations is reference cycles which Cyber addresses with Weak References and it&rsquo;s very own Cycle Detection."><meta property="og:type" content="article"><meta property="og:url" content="https://fubark.github.io/cyber/docs/toc/memory/"><meta property="article:section" content="docs"><title>Memory | Cyber Docs v0.2</title><link rel=manifest href=/cyber/manifest.json><link rel=icon href=/cyber/favicon.png><link rel=stylesheet href=/cyber/book.min.4f0117e74e5337280f18eb9641eae520cb4b25adcf5dd64fafad4664145a5957.css integrity="sha256-TwEX505TNygPGOuWQerlIMtLJa3PXdZPr61GZBRaWVc=" crossorigin=anonymous><script defer src=/cyber/flexsearch.min.js></script>
<script defer src=/cyber/en.search.min.db402b8c46fe1829b7c32e1613e5e896d742a3010e5975362d629f119703c98d.js integrity="sha256-20ArjEb+GCm3wy4WE+XoltdCowEOWXU2LWKfEZcDyY0=" crossorigin=anonymous></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel=stylesheet><link rel=stylesheet href=/cyber/hljs.min.css><link rel=stylesheet href=/cyber/style.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/cyber/><span>Cyber Docs v0.2</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://cyberscript.dev target=_blank rel=noopener>Homepage</a></li><li><a href=https://cyberscript.dev/play.html target=_blank rel=noopener>Playground</a></li></ul><ul><li class=book-section-flat><span>Table of Contents</span><ul><li><a href=/cyber/docs/toc/syntax/>Syntax</a></li><li><a href=/cyber/docs/toc/data-types/>Data Types</a></li><li><a href=/cyber/docs/toc/control-flow/>Control Flow</a></li><li><a href=/cyber/docs/toc/functions/>Functions</a></li><li><a href=/cyber/docs/toc/modules/>Modules</a></li><li><a href=/cyber/docs/toc/ffi/>FFI</a></li><li><a href=/cyber/docs/toc/errors/>Error Handling</a></li><li><a href=/cyber/docs/toc/concurrency/>Concurrency</a></li><li><a href=/cyber/docs/toc/type-system/>Type System</a></li><li><a href=/cyber/docs/toc/metaprogramming/>Metaprogramming</a></li><li><a href=/cyber/docs/toc/embedding/>Embedding</a></li><li><a href=/cyber/docs/toc/memory/ class=active>Memory</a></li><li><a href=/cyber/docs/toc/aot-jit/>AOT/JIT</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/cyber/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Memory</strong>
<label for=toc-control><img src=/cyber/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#arc>ARC.</a><ul><li><a href=#reference-counting>Reference Counting.</a></li><li><a href=#optimizations>Optimizations.</a></li><li><a href=#closures>Closures.</a></li><li><a href=#fibers>Fibers.</a></li></ul></li><li><a href=#heap>Heap.</a></li><li><a href=#weak-references>Weak References.</a></li><li><a href=#cycle-detection>Cycle Detection.</a></li></ul></nav></aside></header><article class=markdown><h1 id=memory>Memory.
<a class=anchor href=#memory>#</a></h1><p>Cyber provides memory safety by default.</p><h2 id=arc>ARC.
<a class=anchor href=#arc>#</a></h2><p>Cyber uses ARC or automatic reference counting to manage memory.
ARC is deterministic and has less overhead compared to a tracing garbage collector. Reference counting distributes memory management, which reduces GC pauses and makes ARC suitable for realtime applications. One common issue in ARC implementations is reference cycles which Cyber addresses with <a href=#weak-references>Weak References</a> and it&rsquo;s very own <a href=#cycle-detection>Cycle Detection</a>.</p><h3 id=reference-counting>Reference Counting.
<a class=anchor href=#reference-counting>#</a></h3><p>In Cyber, there are <a href=/cyber/docs/toc/data-types/>primitive and object</a> values. Primitives don&rsquo;t need any memory management, since they are copied by value and no heap allocation is required (with the exception of primitives being captured by a <a href=#closures>closure</a>).</p><p>Object are managed by ARC and each object has its own reference counter. Upon creating a new object, it receives a reference count of 1. When the object is copied, it&rsquo;s <code>retained</code> and the reference count increments by 1. When an object value is removed from it&rsquo;s parent or is no longer reachable in the current stack frame, it is <code>released</code> and the reference count decrements by 1.</p><p>Once the reference count reaches 0 and the object (eg. List or Map) also contains child references, each child reference is released thereby decrementing their reference counts by 1. Afterwards, the object is freed from memory.</p><h3 id=optimizations>Optimizations.
<a class=anchor href=#optimizations>#</a></h3><p>The compiler can reduce the number of retain/release ops since it can infer value types even though they are dynamically typed to the user. Arguments passed to functions are only retained depending on the analysis from the callsite.</p><h3 id=closures>Closures.
<a class=anchor href=#closures>#</a></h3><p>When primitive variables are captured by a <a href=/cyber/docs/toc/functions/#closures>closure</a>, they are boxed and allocated on the heap. This means they are managed by ARC and cleaned up when there are no more references to them.</p><h3 id=fibers>Fibers.
<a class=anchor href=#fibers>#</a></h3><p><a href=/cyber/docs/toc/concurrency/#fibers>Fibers</a> are freed by ARC just like any other object. Once there are no references to the fiber, it begins to release it&rsquo;s child references by unwinding it&rsquo;s call stack.</p><h2 id=heap>Heap.
<a class=anchor href=#heap>#</a></h2><p>Many object types in Cyber are small enough to be at or under 40 bytes. To take advantage of this, Cyber can reserve object pools to quickly allocate and free these small objects with very little bookkeeping. Bigger objects are allocated and managed by <code>mimalloc</code> which has proven to be a fast and reliable general-purpose heap allocator.</p><h2 id=weak-references>Weak References.
<a class=anchor href=#weak-references>#</a></h2><blockquote><p><em>Planned Feature</em></p></blockquote><h2 id=cycle-detection>Cycle Detection.
<a class=anchor href=#cycle-detection>#</a></h2><p>The cycle detector is also considered a GC and frees abandoned objects managed by ARC. Although weak references can remove cycles altogether, Cyber does not force you to use them and provides a manual GC as a one-time catch all solution.</p><blockquote><p><em>Incomplete Feature: Only the main fiber stack is cleaned up at the moment.</em></p></blockquote><p>To invoke the GC, call the builtin function: <code>performGC</code>.</p><pre tabindex=0><code class=language-cy data-lang=cy>func foo():
  -- Create a reference cycle.
  var a = []
  var b = []
  a.append(b)
  b.append(a)

  var res = performGC()
  -- Cycle still alive in the current stack so no cleanup is done.
  print res[&#39;numCycFreed&#39;]    -- Output: 0
  print res[&#39;numObjFreed&#39;]    -- Output: 0

foo()
var res = performGC()
-- `a` and `b` are no longer reachable, so the GC does work.
print res[&#39;numCycFreed&#39;]      -- Output: 2
print res[&#39;numObjFreed&#39;]      -- Output: 2
</code></pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/fubark/cyber/edit/master/docs/hugo/content/docs/toc/memory.md target=_blank rel=noopener><img src=/cyber/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#arc>ARC.</a><ul><li><a href=#reference-counting>Reference Counting.</a></li><li><a href=#optimizations>Optimizations.</a></li><li><a href=#closures>Closures.</a></li><li><a href=#fibers>Fibers.</a></li></ul></li><li><a href=#heap>Heap.</a></li><li><a href=#weak-references>Weak References.</a></li><li><a href=#cycle-detection>Cycle Detection.</a></li></ul></nav></div></aside></main><script src=/cyber/highlight.min.js></script>
<script>hljs.registerLanguage("cy",function(){return{keywords:{keyword:["func","import","for","coinit","coresume","coyield","return","if","then","else","as","each","while","var","object","break","continue","match","pass","or","and","not","is","some","error","static","capture","true","false","none","throw","try","catch","recover","enum","type"],type:["float","string","bool","any","int","List","Map","rawstring","symbol","pointer"]},contains:[{scope:"string",begin:"'",end:"'"},{scope:"symbol",begin:"#",end:/\w(?=[^\w])/},hljs.COMMENT("--",`
`,{contains:[]}),hljs.C_NUMBER_MODE]}}),hljs.highlightAll()</script></body></html>